## 1、日志框架

 小张；开发一个大型系统；

​		1、System.out.println("")；将关键数据打印在控制台；去掉？写在一个文件？

​		2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；

​		3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？

​		4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；

​		5、JDBC---数据库驱动；

​			写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；

​			给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；



**市面上的日志框架；**

JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j....

| 日志门面  （日志的抽象层）                                   | 日志实现                                                     |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| ~~JCL（Jakarta  Commons Logging）~~            SLF4j（Simple  Logging Facade for Java）             **~~jboss-logging~~** | Log4j  JUL（java.util.logging）  Log4j2              **Logback** |

左边选一个门面（抽象层）、右边来选一个实现；

日志门面：  SLF4J；

日志实现：Logback；



SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘

​	**==SpringBoot选用 SLF4j和logback；==**



## 2、SLF4j使用

### 1、如何在系统中使用SLF4j   https://www.slf4j.org

以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；

给系统里面导入slf4j的jar和  logback的实现jar

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {
  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}
```

图示；

![images/concrete-bindings.png](D:/my/study/Typora书写的各种笔记/spring相关学习笔记/Spring Boot 笔记+课件/images/concrete-bindings.png)

每一个日志的实现框架都有自己的配置文件。使用slf4j以后，**配置文件还是做成日志实现框架自己本身的配置文件；**

### 2、遗留问题

a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx

统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？

![](D:/my/study/Typora书写的各种笔记/spring相关学习笔记/Spring Boot 笔记+课件/images/legacy.png)

**如何让系统中所有的日志都统一到slf4j；**

==1、将系统中其他日志框架先排除出去；==

==2、用中间包来替换原有的日志框架；==

==3、我们导入slf4j其他的实现==



## 3、SpringBoot日志关系

```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
```



SpringBoot使用它来做日志功能；

```xml
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-logging</artifactId>
		</dependency>
```

底层依赖关系

![](D:/my/study/Typora书写的各种笔记/spring相关学习笔记/Spring Boot 笔记+课件/images/搜狗截图20180131220946.png)

总结：

​	1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录

​	2）、SpringBoot也把其他的日志都替换成了slf4j；

​	3）、中间替换包？

```java
@SuppressWarnings("rawtypes")
public abstract class LogFactory {

    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j";

    static LogFactory logFactory = new SLF4JLogFactory();
```

![](D:/my/study/Typora书写的各种笔记/spring相关学习笔记/Spring Boot 笔记+课件/images/搜狗截图20180131221411.png)



​	4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？

​			Spring框架用的是commons-logging；

```xml
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<exclusions>
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
```

**==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；==**

## 4、日志使用；

### 1、默认配置

SpringBoot默认帮我们配置好了日志；

```java
	//记录器
	Logger logger = LoggerFactory.getLogger(getClass());
	@Test
	public void contextLoads() {
		//System.out.println();

		//日志的级别；
		//由低到高   trace<debug<info<warn<error
		//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效
		logger.trace("这是trace日志...");
		logger.debug("这是debug日志...");
		//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别
		logger.info("这是info日志...");
		logger.warn("这是warn日志...");
		logger.error("这是error日志...");


	}
```



        日志输出格式：
    		%d表示日期时间，
    		%thread表示线程名，
    		%-5level：级别从左显示5个字符宽度
    		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
    		%msg：日志消息，
    		%n是换行符
        -->
        %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n

SpringBoot修改日志的默认配置

```properties
logging.level.com.atguigu=trace


#logging.path=
# 不指定路径在当前项目下生成springboot.log日志
# 可以指定完整的路径；
#logging.file=G:/springboot.log

# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
logging.path=/spring/log

#  在控制台输出的日志的格式
logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
# 指定文件中日志输出的格式
logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n
```

| logging.file | logging.path | Example  | Description                        |
| ------------ | ------------ | -------- | ---------------------------------- |
| (none)       | (none)       |          | 只在控制台输出                     |
| 指定文件名   | (none)       | my.log   | 输出日志到my.log文件               |
| (none)       | 指定目录     | /var/log | 输出到指定目录的 spring.log 文件中 |

### 2、指定配置

给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了

| Logging System          | Customization                                                |
| ----------------------- | ------------------------------------------------------------ |
| Logback                 | `logback-spring.xml`, `logback-spring.groovy`, `logback.xml` or `logback.groovy` |
| Log4j2                  | `log4j2-spring.xml` or `log4j2.xml`                          |
| JDK (Java Util Logging) | `logging.properties`                                         |

logback.xml：直接就被日志框架识别了；

**logback-spring.xml**：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能

```xml
<springProfile name="staging">
    <!-- configuration to be enabled when the "staging" profile is active -->
  	可以指定某段配置只在某个环境下生效
</springProfile>

```

如：

```xml
<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <!--
        日志输出格式：
			%d表示日期时间，
			%thread表示线程名，
			%-5level：级别从左显示5个字符宽度
			%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
			%msg：日志消息，
			%n是换行符
        -->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <springProfile name="dev">
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>
            </springProfile>
            <springProfile name="!dev">
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n</pattern>
            </springProfile>
        </layout>
    </appender>
```



如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误

 `no applicable action for [springProfile]`

## 5、切换日志框架

可以按照slf4j的日志适配图，进行相关的切换；

slf4j+log4j的方式；

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <exclusion>
      <artifactId>logback-classic</artifactId>
      <groupId>ch.qos.logback</groupId>
    </exclusion>
    <exclusion>
      <artifactId>log4j-over-slf4j</artifactId>
      <groupId>org.slf4j</groupId>
    </exclusion>
  </exclusions>
</dependency>

<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
</dependency>

```





切换为log4j2

```xml
   <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <artifactId>spring-boot-starter-logging</artifactId>
                    <groupId>org.springframework.boot</groupId>
                </exclusion>
            </exclusions>
        </dependency>

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

# logback文档解读

## 文档地址

http://logback.qos.ch/manual/index.html

![image-20200420173402665](D:\my\study\TyporaNote\工具的学习文档\imgs\image-20200420173402665.png)

## 1.Logback's 结构

logback is divided into three modules, logback-core, logback-classic and logback-access.

Logback建立在三个主要的类上:Logger、Appender和Layout。这三种类型的组件协同工作，使开发人员能够根据消息类型和级别记录消息，并在运行时控制这些消息的格式和报告位置。

Logger类是logback-classic模块的一部分。另一方面，Appender和布局接口是logback-core的一部分。作为一个通用模块，logback-core没有日志记录器的概念。

## 2.Logger 

### 日志名称层次规则

the logger named `"com.foo"` is a parent of the logger named `"com.foo.Bar"`. Similarly, `"java"` is a parent of `"java.util"` and an ancestor of `"java.util.Vector"`. This naming scheme should be familiar to most developers.



All other loggers are also retrieved with the class static `getLogger` method found in the [org.slf4j.LoggerFactory](http://www.slf4j.org/api/org/slf4j/Logger.html) class.

### 有效级别又名级别继承

日志记录器可能被分配到不同的级别。可能的级别集(TRACE, DEBUG, INFO, WARN and ERROR)在ch. qm .log .classic中定义。

如果一个给定的日志记录器没有被分配一个级别，那么它将从最近的祖先那里继承一个级别并分配一个级别。

示例

| Logger name | Assigned level | Effective level |
| ----------- | -------------- | --------------- |
| root        | DEBUG          | DEBUG           |
| X           | INFO           | INFO            |
| X.Y         | none           | INFO            |
| X.Y.Z       | none           | INFO            |

### 打印方法和基本选择规则

如果日志记录请求的级别高于或等于其日志记录器的有效级别，则称为启用日志记录请求。

等级划分 `TRACE < DEBUG < INFO <  WARN < ERROR`.

| level of request *p* | effective level *q* |         |         |         |         |        |
| -------------------- | ------------------- | ------- | ------- | ------- | ------- | ------ |
| TRACE                | DEBUG               | INFO    | WARN    | ERROR   | OFF     |        |
| TRACE                | **YES**             | **NO**  | **NO**  | **NO**  | **NO**  | **NO** |
| DEBUG                | **YES**             | **YES** | **NO**  | **NO**  | **NO**  | **NO** |
| INFO                 | **YES**             | **YES** | **YES** | **NO**  | **NO**  | **NO** |
| WARN                 | **YES**             | **YES** | **YES** | **YES** | **NO**  | **NO** |
| ERROR                | **YES**             | **YES** | **YES** | **YES** | **YES** | **NO** |

高于设置的级别 对应的打印级别才生效

比如设置了info级别  那么只有error warn info 级别才能打印

## 3.Appenders and Layouts

Logback允许将日志请求打印到多个目的地。在logback中，输出目的地称为追加器（Appenders）

目前，针对控制台、文件、远程套接字服务器、MySQL、PostgreSQL、Oracle和其他数据库、JMS和远程UNIX Syslog守护进程的附加程序已经存在。

例如，如果将控制台追加器添加到根日志记录器，那么所有启用的日志请求至少都将在控制台打印。如果另外向日志记录器(比如L)添加了一个文件追加器，那么L和L的子元素的启用日志记录请求将打印在文件和控制台上。

The table below shows an example:

| Logger Name     | Attached Appenders | Additivity Flag | Output Targets         | Comment                                                      |
| --------------- | ------------------ | --------------- | ---------------------- | ------------------------------------------------------------ |
| root            | A1                 | not applicable  | A1                     | Since the root logger stands at the top of the logger hierarchy, the additivity flag does not apply to it. |
| x               | A-x1, A-x2         | true            | A1, A-x1, A-x2         | Appenders of "x" and of root.                                |
| x.y             | none               | true            | A1, A-x1, A-x2         | Appenders of "x" and of root.                                |
| x.y.z           | A-xyz1             | true            | A1, A-x1, A-x2, A-xyz1 | Appenders of "x.y.z", "x" and of root.                       |
| security        | A-sec              | false           | A-sec                  | No appender accumulation since the additivity flag is set to `false`. Only appender A-sec will be used. |
| security.access | none               | true            | A-sec                  | Only appenders of "security" because the additivity flag in "security" is set to `false`. |

通常，用户不仅希望自定义输出目的地，还希望自定义输出格式。这是通过将布局与追加器关联来实现的。

布局负责根据用户的愿望对日志请求进行格式化，而appender负责将格式化的输出发送到它的目的地。PatternLayout是标准logback分发版的一部分，它允许用户根据类似于C语言printf函数的转换模式指定输出格式。

For example, the PatternLayout with the conversion pattern "%-4relative [%thread] %-5level %logger{32} - %msg%n" will output something akin to:

```
176  [main] DEBUG manual.architecture.HelloWorld2 - Hello world.
```

第一个字段是程序开始后经过的毫秒数。

第二个字段是发出日志请求的线程。

第三个字段是日志请求的级别。

第四个字段是与日志请求关联的日志记录器的名称。

'-'后面的文本是请求的消息。

## 4.变量日志追踪

There exists a convenient alternative based on message formats. Assuming `entry` is an object, you can write:

```java
Object entry = new SomeObject(); 
Object entry1 = new SomeObject(); 
logger.debug("The entry is {}.", entry);
#使用下面这个
logger.debug("The new entry is "+entry+".")
  //            字符创拼接的方法监测变量         
			log.info("info..., "+name+" ,password:"+password);
//            利用日志特殊表达式，自动装入占位符
            log.info("info..."+"name: {},password: {}",name,password);
```

如果需要传递三个或多个参数，还可以使用Object[]变体。例如，你可以这样写:

~~~java
Object[] paramArray = {newVal, below, above};
logger.debug("Value {} was inserted between {} and {}.", paramArray);
~~~



只有在评估是否进行日志记录之后，并且只有在决定为正数时，日志记录器实现才会格式化消息并将“{}”对替换为条目的字符串值。换句话说，当日志语句被禁用时，此表单不会产生参数构造的成本。

## 5.Configuration file syntax

logback配置文件的语法非常灵活。因此，不可能使用DTD文件或XML模式指定允许的语法。然而，配置文件的基本结构可以这样描述:<configuration>元素，包含0个或多个<appender>元素，然后是0个或多个<logger>元素，最多一个<root>元素。下图说明了这种基本结构。

![basic Syntax](D:\my\study\TyporaNote\工具的学习文档\imgs\basicSyntax.png)

#### 5.1.logger标签

创建日志检测对象

<logger>元素只接受一个强制的name属性将那个类创建一个日志检测对象、一个可选的level属性和一个可选的additivity属性，允许值为真或假。level属性的值允许一个不区分大小写的字符串值TRACE、DEBUG、INFO、WARN、ERROR、ALL或OFF。继承的不区分大小写的特殊值或它的同义词NULL将强制从层次结构的更高层继承日志程序的级别。如果您设置了一个日志程序的级别，然后决定它应该继承它的级别，那么这将非常方便

<logger>元素可以包含0个或多个<appender-ref>元素;这样引用的每个appender都被添加到指定的日志记录器中。请注意，与log4j不同，logback-classic在配置给定的日志程序时既不关闭也不删除任何以前引用的附加程序。

additivity属性：如果默认的累积行为不适合您的需要，您可以通过将additivity标记设置为false来覆盖它。因此，日志记录器树中的分支可能将输出定向到一组与树的其他部分不同的附加程序。

#### 5.2.root标签

创建根日志记录器，所有其他的检测对象不单独设置的话默认继承

然后Configuring the root logger, or the root element

<root>元素配置根日志记录器。它支持单个属性，即level属性。它不允许任何其他属性，因为可加性标记不应用于根记录器。而且，由于根日志记录器已经被命名为“root”，所以它也不允许使用名称属性。level属性的值可以是不区分大小写的字符串之一TRACE、DEBUG、INFO、WARN、ERROR、ALL或OFF。请注意，不能将根日志记录器的级别设置为INHERITED或NULL。

与<logger>元素类似，<root>元素可以包含0个或多个<appender-ref>元素;这样引用的每个appender都被添加到根日志记录器中。

##### 示例

设置日志程序或根日志程序的级别非常简单，只需声明它并设置它的级别，如下一个示例所示。假设我们不再对来自“"chapters.configuration"”的任何组件的debug消息感兴趣。下面的配置文件展示了如何实现这一点。

~~~xml
<configuration>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="chapters.configuration" level="INFO"/>
  <logger name="chapters.configuration.Foo" level="DEBUG" />

  <!-- Strictly speaking, the level attribute is not necessary since -->
  <!-- the level of the root level is set to DEBUG by default.       -->
  <root level="DEBUG">          
    <appender-ref ref="STDOUT" />
  </root>  
  
</configuration>
~~~

输出信息

~~~console
17:39:27.593 [main] INFO  chapters.configuration.MyApp3 - Entering application.
17:39:27.593 [main] DEBUG chapters.configuration.Foo - Did it again!
17:39:27.593 [main] INFO  chapters.configuration.MyApp3 - Exiting application.
~~~

优先级如下表

| Logger name                   | Assigned Level | Effective Level |
| ----------------------------- | -------------- | --------------- |
| root                          | `DEBUG`        | `DEBUG`         |
| chapters.configuration        | `INFO`         | `INFO`          |
| chapters.configuration.MyApp3 | `null`         | `INFO`          |
| chapters.configuration.Foo    | `DEBUG`        | `DEBUG`         |

#### 5.3配appenders标签

附加程序必须实现ch.qos.logback.core.Appender接口。

##### 继承关系图各类解释

![A UML diagram showing OutputStreamAppender and sub-classes](D:\my\study\TyporaNote\工具的学习文档\imgs\appenderClassDiagram.jpg)

##### OutputStreamAppender

| Property Name      | Type                                                         | Description                                                  |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **encoder**        | [`Encoder`](http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html) | Determines the manner in which an event is written to the underlying `OutputStreamAppender`. Encoders are described in a [dedicated chapter](http://logback.qos.ch/manual/encoders.html). |
| **immediateFlush** | `boolean`                                                    | 即时刷新的默认值是‘true’。输出流的立即刷新确保日志事件被立即写出来，并且在应用程序没有正确关闭附加程序而退出时不会丢失。另一方面，将此属性设置为“false”可能会使日志吞吐量增加四倍(您的里程可能有所不同)。同样，如果immediateFlush设置为“false”，并且在应用程序退出时没有正确关闭appenders，那么还没有写到磁盘的日志事件可能会丢失。 |

##### ConsoleAppender

ConsoleAppender附加在控制台，或者更准确地说是系统上。或系统。呃，前者是默认目标。ConsoleAppender在用户指定的编码器的帮助下格式化事件。

| Property Name | Type                                                         | Description                                                  |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **encoder**   | [`Encoder`](http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html) | See `OutputStreamAppender` properties.                       |
| **target**    | `String`                                                     | One of the String values *System.out* or *System.err*. The default target is *System.out*. |

##### FileAppender

FileAppender是OutputStreamAppender的子类，它将日志事件附加到文件中。目标文件由file选项指定。如果文件已经存在，则根据append属性的值将其追加或截断。

| Property Name | Type                                                         | Description                                                  |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **append**    | `boolean`                                                    | If true, events are appended at the end of an existing file. Otherwise, if append is false, any existing file is truncated. The append option is set to true by default. |
| **encoder**   | [`Encoder`](http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html) | See `OutputStreamAppender` properties.                       |
| **file**      | `String`                                                     | The name of the file to write to. If the file does not exist, it is created. On the MS Windows platform users frequently forget to escape back slashes. For example, the value *c:\temp\test.log* is not likely to be interpreted properly as *'\t'* is an escape sequence interpreted as a single tab character *(\u0009)*. Correct values can be specified as *c:/temp/test.log* or alternatively as *c:\\temp\\test.log*. The File option has no default value.If the parent directory of the file does not exist, `FileAppender` will automatically create it, including any necessary but nonexistent parent directories. |
|               |                                                              |                                                              |

~~~xml
<configuration>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>testFile.log</file>
    <append>true</append>
    <!-- set immediateFlush to false for much higher logging throughput -->
    <immediateFlush>true</immediateFlush>
    <!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    <encoder>
      <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
    </encoder>
  </appender>
        
  <root level="DEBUG">
    <appender-ref ref="FILE" />
  </root>
</configuration>
~~~

###### 唯一命名的文件(根据时间戳)

在应用程序开发阶段，或者在短期应用程序(例如批处理应用程序)的情况下，最好在每次新应用程序启动时创建一个新的日志文件。在<timestamp>元素的帮助下，这是相当容易做到的。这是一个例子。

~~~xml
<configuration>

  <!-- Insert the current time formatted as "yyyyMMdd'T'HHmmss" under
       the key "bySecond" into the logger context. This value will be
       available to all subsequent configuration elements. -->
  <timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <!-- use the previously created timestamp to create a uniquely
         named log file -->
    <file>log-${bySecond}.txt</file>
    <encoder>
      <pattern>%logger{35} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="DEBUG">
    <appender-ref ref="FILE" />
  </root>
</configuration>
~~~

##### 滚动文件RollingFileAppender

RollingFileAppender将FileAppender扩展为可以滚动日志文件的功能

有两个重要的子组件与RollingFileAppender交互。

第一个RollingFileAppender子组件，即RollingPolicy(见下面)，负责执行改变所需的操作。

第二个子组件，即TriggeringPolicy(参见下面)，将确定是否以及何时发生改变。

要想使用，RollingFileAppender必须同时设置RollingPolicy和TriggeringPolicy

Here are the available properties for `RollingFileAppender`:

| Property Name        | Type                                                         | Description                                                  |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **file**             | `String`                                                     | See `FileAppender` properties.                               |
| **append**           | `boolean`                                                    | See `FileAppender` properties.                               |
| **encoder**          | [`Encoder`](http://logback.qos.ch/xref/ch/qos/logback/core/encoder/Encoder.html) | See `OutputStreamAppender` properties.                       |
| **rollingPolicy**    | `RollingPolicy`                                              | This option is the component that will dictate `RollingFileAppender`'s behavior when rollover occurs. See more information below. |
| **triggeringPolicy** | `TriggeringPolicy`                                           | This option is the component that will tell `RollingFileAppender` when to activate the rollover procedure. See more information below. |
| **prudent**          | `boolean`                                                    | [`FixedWindowRollingPolicy`](http://logback.qos.ch/manual/appenders.html#FixedWindowRollingPolicy) is not supported in prudent mode.`RollingFileAppender` supports the prudent mode in conjunction with [`TimeBasedRollingPolicy`](http://logback.qos.ch/manual/appenders.html#TimeBasedRollingPolicy) albeit with two restrictions.In prudent mode, file compression is not supported nor allowed. (We can't have one JVM writing to a file while another JVM is compressing it.)The file property of `FileAppender` cannot be set and must be left blank. Indeed, most operating systems do not allow renaming of a file while another process has it opened.See also properties for `FileAppender`. |

###### TimeBasedRollingPolicy

它根据时间(例如按天或按月)定义滚动策略。基于时间的滚转策略承担滚转和触发滚转的责任。

`TimeBasedTriggeringPolicy` implements *both* `RollingPolicy` and `TriggeringPolicy` interfaces.

TimeBasedRollingPolicy的配置采用一个强制性的fileNamePattern属性和几个可选属性。

| Property Name           | Type     | Description                                                  |
| ----------------------- | -------- | ------------------------------------------------------------ |
| **fileNamePattern**     | `String` | The mandatory fileNamePattern property defines the name of the rolled-over (archived) log files. Its value should consist of the name of the file, plus a suitably placed *%d* conversion specifier. The *%d* conversion specifier may contain a date-and-time pattern as specified by the `java.text.SimpleDateFormat` class. If the date-and-time pattern is omitted, then the default pattern *yyyy-MM-dd* is assumed. **The rollover period is inferred from the value of fileNamePattern.**Note that the file property in `RollingFileAppender` (the parent of `TimeBasedRollingPolicy`) can be either set or omitted. By setting the file property of the containing `FileAppender`, you can decouple the location of the active log file and the location of the archived log files. The current logs will be always targeted at the file specified by the file property. It follows that the name of the currently active log file will not change over time. However, if you choose to omit the file property, then the active file will be computed anew for each period based on the value of fileNamePattern. The examples below should clarify this point.The date-and-time pattern, as found within the accolades of %d{} follow java.text.SimpleDateFormat conventions. The forward slash '/' or backward slash '\' characters anywhere within the fileNamePattern property or within the date-and-time pattern will be interpreted as directory separators.Multiple %d specifiersIt is possible to specify multiple %d specifiers but only one of which can be primary, i.e. used to infer the rollover period. All other tokens *must* be marked as auxiliary by passing the 'aux' parameter (see examples below).Multiple %d specifiers allow you to organize archive files in a folder structure different than that of the roll-over period. For example, the file name pattern shown below organizes log folders by year and month but roll-over log files every day at midnight.`/var/log/**%d{yyyy/MM, aux}**/myapplication.**%d{yyyy-MM-dd}**.log`TimeZoneUnder certain circumstances, you might wish to roll-over log files according to a clock in a timezone different than that of the host. It is possible to pass a timezone argument following the date-and-time pattern within the %d conversion specifier. For example:`aFolder/test.**%d**{yyyy-MM-dd-HH, **UTC**}.log`If the specified timezone identifier is unknown or misspelled, the GMT timezone is assumed as dictated by the [TimeZone.getTimeZone(String)](http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)) method specification. |
| **maxHistory**          | int      | The optional maxHistory property controls the maximum number of archive files to keep, asynchronously deleting older files. For example, if you specify monthly rollover, and set maxHistory to 6, then 6 months worth of archives files will be kept with files older than 6 months deleted. Note as old archived log files are removed, any folders which were created for the purpose of log file archiving will be removed as appropriate. |
| **totalSizeCap**        | int      | The optional totalSizeCap property controls the total size of all archive files. Oldest archives are deleted asynchronously when the total size cap is exceeded. The totalSizeCap property requires maxHistory property to be set as well. Moreover, the "max history" restriction is always applied first and the "total size cap" restriction applied second. |
| **cleanHistoryOnStart** | boolean  | If set to true, archive removal will be executed on appender start up. By default this property is set to false.Archive removal is normally performed during roll over. However, some applications may not live long enough for roll over to be triggered. It follows that for such short-lived applications archive removal may never get a chance to execute. By setting cleanHistoryOnStart to true, archive removal is performed at appender start up. |

Here are a few `fileNamePattern` values with an explanation of their effects.

| fileNamePattern                            | Rollover schedule                                            | Example                                                      |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| */wombat/foo.%d*                           | Daily rollover (at midnight). Due to the omission of the optional time and date pattern for the *%d* token specifier, the default pattern of *yyyy-MM-dd* is assumed, which corresponds to daily rollover. | file property not set: During November 23rd, 2006, logging output will go to the file */wombat/foo.2006-11-23*. At midnight and for the rest of the 24th, logging output will be directed to */wombat/foo.2006-11-24*.file property set to */wombat/foo.txt*: During November 23rd, 2006, logging output will go to the file */wombat/foo.txt*. At midnight, *foo.txt* will be renamed as */wombat/foo.2006-11-23*. A new */wombat/foo.txt* file will be created and for the rest of November 24th logging output will be directed to *foo.txt*. |
| */wombat/%d{yyyy/MM}/foo.txt*              | Rollover at the beginning of each month.                     | file property not set: During the month of October 2006, logging output will go to */wombat/2006/10/foo.txt*. After midnight of October 31st and for the rest of November, logging output will be directed to */wombat/2006/11/foo.txt*.file property set to */wombat/foo.txt*: The active log file will always be */wombat/foo.txt*. During the month of October 2006, logging output will go to */wombat/foo.txt*. At midnight of October 31st, */wombat/foo.txt* will be renamed as */wombat/2006/10/foo.txt*. A new */wombat/foo.txt* file will be created where logging output will go for the rest of November. At midnight of November 30th, */wombat/foo.txt* will be renamed as */wombat/2006/11/foo.txt* and so on. |
| */wombat/foo.%d{yyyy-ww}.log*              | Rollover at the first day of each week. Note that the first day of the week depends on the locale. | Similar to previous cases, except that rollover will occur at the beginning of every new week. |
| */wombat/foo%d{yyyy-MM-dd_HH}.log*         | Rollover at the top of each hour.                            | Similar to previous cases, except that rollover will occur at the top of every hour. |
| */wombat/foo%d{yyyy-MM-dd_HH-mm}.log*      | Rollover at the beginning of every minute.                   | Similar to previous cases, except that rollover will occur at the beginning of every minute. |
| */wombat/foo%d{yyyy-MM-dd_HH-mm, UTC}.log* | Rollover at the beginning of every minute.                   | Similar to previous cases, except that file names will be expressed in UTC. |
| */foo/%d{yyyy-MM,**aux**}/%d.log*          | Rollover daily. Archives located under a folder containing year and month. | In this example, the first %d token is marked as **aux**iliary. The second %d token, with time and date pattern omitted, is then assumed to be primary. Thus, rollover will occur daily (default for %d) and the folder name will depend on the year and month. For example, during the month of November 2006, archived files will all placed under the /foo/2006-11/ folder, e.g */foo/2006-11/2006-11-14.log*. |

任何向前或向后斜杠字符都被解释为文件夹(目录)分隔符。任何需要的文件夹都将根据需要创建。因此，您可以轻松地将日志文件放在单独的文件夹中。

下面是RollingFileAppender与TimeBasedRollingPolicy的示例配置。

~~~xml
<configuration>
  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logFile.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <!-- daily rollover -->
      <fileNamePattern>logFile.%d{yyyy-MM-dd}.log</fileNamePattern>

      <!-- keep 30 days' worth of history capped at 3GB total size -->
      <maxHistory>30</maxHistory>
      <totalSizeCap>3GB</totalSizeCap>

    </rollingPolicy>

    <encoder>
      <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
    </encoder>
  </appender> 

  <root level="DEBUG">
    <appender-ref ref="FILE" />
  </root>
</configuration>
~~~

###### SizeAndTimeBasedRollingPolicy

有时，您可能希望按日期归档文件，但同时限制每个日志文件的大小，特别是在后处理工具对日志文件施加大小限制的情况下。为了满足这一需求，使用SizeAndTimeBasedRollingPolicy。

示例

~~~xml
<configuration>
  <appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>mylog.txt</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <!-- rollover daily -->
      <fileNamePattern>mylog-%d{yyyy-MM-dd}.%i.txt</fileNamePattern>
       <!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB -->
       <maxFileSize>100MB</maxFileSize>    
       <maxHistory>60</maxHistory>
       <totalSizeCap>20GB</totalSizeCap>
    </rollingPolicy>
    <encoder>
      <pattern>%msg%n</pattern>
    </encoder>
  </appender>


  <root level="DEBUG">
    <appender-ref ref="ROLLING" />
  </root>

</configuration>
~~~

注意除了“%d”之外，还有“%i”转换令牌。%i和%d令牌都是必需的。每次当前日志文件在当前时间段结束之前达到maxFileSize时，都将以递增的索引进行归档，从0开始。

##### 触发策略概述TriggeringPolicy

SizeBasedTriggeringPolicy查看当前活动文件的大小。如果它的大小超过了指定的大小，它将向拥有RollingFileAppender发出信号，以触发现有活动文件的翻转。

`SizeBasedTriggeringPolicy` accepts only one parameter, namely maxFileSize, with a default value of 10 MB.

~~~xml
<configuration>
  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>test.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
      <fileNamePattern>test.%i.log.zip</fileNamePattern>
      <minIndex>1</minIndex>
      <maxIndex>3</maxIndex>
    </rollingPolicy>

    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>5MB</maxFileSize>
    </triggeringPolicy>
    <encoder>
      <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
    </encoder>
  </appender>
        
  <root level="DEBUG">
    <appender-ref ref="FILE" />
  </root>
</configuration>
~~~

##### encoder标签

编码器负责将事件转换为字节数组，并将字节数组写入OutputStream。

FileAppender和子类需要一个编码器，不再需要布局。

Since logback 0.9.19, `FileAppender` and sub-classes [expect an encoder and no longer take a layout](http://logback.qos.ch/codes.html#layoutInsteadOfEncoder).



##### 定义

Logback将编写日志事件的任务委托给称为appenders的组件。附加程序必须实现ch.qos.logback.core。Appender接口。

接口中的doAppend()方法可能是logback框架中最重要的方法。它负责将日志事件以适当的格式输出到适当的输出设备

Appenders最终负责输出日志事件。但是，它们可以将事件的实际格式化委托给 Layout布局或编码器Encoder对象。每个布局/编码器都与一个且只有一个附加器相关联，称为拥有附加器。有些appender具有内置的或固定的事件格式。因此，他们不需要也没有布局/编码器。例如，SocketAppender只是在通过网络传输日志事件之前对其进行序列化。

Appender接口扩展了filterattable接口。可以将一个或多个过滤器附加到一个appender实例。



appender使用<appender>元素配置，该元素接受两个必需的属性名称和类。

name属性指定了appender的名称，而class属性指定了要实例化的appender类的完全限定名。<appender>元素可以包含零个或一个<layout>元素，零个或多个<encoder>元素，零个或多个<filter>元素。除了这三个常见元素之外，<appender>元素可以包含任意数量的与appender类的JavaBean属性相对应的元素。无缝地支持给定logback组件的任何属性是Joran的主要优势之一，这将在后面的章节中讨论。以下diagra

![Appender Syntax](D:\my\study\TyporaNote\工具的学习文档\imgs\appenderSyntax.png)

<layout>元素接受一个强制性的class属性，该属性指定要实例化的layout类的完全限定名。与<appender>元素一样，<layout>可能包含与布局实例的属性相对应的其他元素。因为这是一种常见的情况，如果布局类是PatternLayout，那么可以按照默认的类映射规则省略class属性。

<encoder>元素接受一个强制的类属性，该属性指定要实例化的编码器类的完全限定名。因为这是很常见的情况，如果encoder类是PatternLayoutEncoder，那么可以按照默认的类映射规则省略class属性。

将日志记录到多个追加器与定义各种追加器并在日志记录器中引用它们一样简单，如下面的配置文件所示:

示例

~~~xml
<configuration>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>myApp.log</file>

    <encoder>
      <pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="FILE" />
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
~~~

##### 输出源积累

~~~xml
<configuration>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="chapters.configuration">
    <appender-ref ref="STDOUT" />
  </logger>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
~~~

输出

~~~console
14:25:36.343 [main] INFO  chapters.configuration.MyApp3 - Entering application.
14:25:36.343 [main] INFO  chapters.configuration.MyApp3 - Entering application.
14:25:36.359 [main] DEBUG chapters.configuration.Foo - Did it again!
14:25:36.359 [main] DEBUG chapters.configuration.Foo - Did it again!
14:25:36.359 [main] INFO  chapters.configuration.MyApp3 - Exiting application.
14:25:36.359 [main] INFO  chapters.configuration.MyApp3 - Exiting application.
~~~

注意重复的输出。名为STDOUT的追加器被附加到两个日志记录器，分别到root和chapters.configuration。因为根日志记录器是所有日志记录器和章节的祖先。configuration是这两章的父类。MyApp3 chapters.configuration。Foo，用这两个日志记录器发出的每个日志记录请求将输出两次，一次，因为STDOUT附属于章节。配置一次，因为它是根结点。

可以利用这点将其分别输出到不同的地方

```xml
<configuration>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>myApp.log</file>
    <encoder>
      <pattern>%date %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%msg%n</pattern>
    </encoder>
  </appender>

  <logger name="chapters.configuration">
    <appender-ref ref="FILE" />
  </logger>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
```

##### 覆盖默认的累积行为

如果默认的累积行为不适合您的需要，您可以通过将additivity标记设置为false来覆盖它。因此，日志记录器树中的分支可能将输出定向到一组与树的其他部分不同的附加程序。

```xml
<configuration>

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>foo.log</file>
    <encoder>
      <pattern>%date %level [%thread] %logger{10} [%file : %line] %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%msg%n</pattern>
    </encoder>
  </appender>

  <logger name="chapters.configuration.Foo" additivity="false">
    <appender-ref ref="FILE" />
  </logger>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
```

在本例中，名为FILE的追加器被附加到chapters.configuration.Foo记录器。此外,chapters.configuration。Foo logger将其可加性标记设置为false，这样它的日志输出将被发送到指定的appender文件，而不是发送到层次结构中更高的任何appender。其他日志记录器仍然不知道chapters.configuration的可加性设置。Foo记录器。使用additivityFlag.xml配置文件运行MyApp3应用程序，将会在控制台中从chapter .configuration中输出结果。MyApp3记录器。 However, output from the *chapters.configuration.Foo* logger will appear in the *foo.log* file and only in that file.

##### 配置上下文名称

如前一章所述，每个日志记录器都附加到一个日志记录器上下文。默认情况下，日志记录器上下文称为“default”。但是，您可以在<contextName>配置指令的帮助下设置一个不同的名称。请注意，一旦设置好，就不能更改记录器上下文名称。设置上下文名称是一种简单而直接的方法，以便将多个应用程序日志记录到同一个目标之间加以区分。

~~~xml
<configuration>
  <contextName>myAppName</contextName>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d %contextName [%t] %level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
~~~

#### layout

用来格式化字符的

##### PatternLayout

Logback classic ships with a flexible layout called [`PatternLayout`](http://logback.qos.ch/xref/ch/qos/logback/classic/PatternLayout.html).

与所有布局一样，PatternLayout接受一个日志事件并返回一个字符串。

您可以自由地在转换模式中插入任何文本。每个转换说明符以百分号'%'开头，后面是可选的格式修饰符、转换字和大括号之间的可选参数。转换字控制要转换的数据字段

正如前面多次提到的，FileAppender和子类需要一个encoder。因此，当与FileAppender或其子类一起使用时，模式布局必须包装在encoder中。

下表描述了可识别的转换词及其选项。当多个转换词在同一个表单元格中列出时，它们被视为别名。

| [Conversion Word](http://logback.qos.ch/manual/layouts.html#conversionWord) | Effect                                                       |      |      |
| ------------------------------------------------------------ | :----------------------------------------------------------- | ---- | ---- |
| **c**{*length*} **lo**{*length*} **logger**{*length*}        | Outputs the name of the logger at the origin of the logging event.This conversion word takes an integer as its first and only option. The converter's abbreviation algorithm will shorten the logger name, usually without significant loss of meaning. Setting the value of length option to zero constitutes an exception. It will cause the conversion word to return the sub-string right to the rightmost dot character in the logger name. The next table provides examples of the abbreviation algorithm in action.Conversion specifierLogger nameResult%loggermainPackage.sub.sample.BarmainPackage.sub.sample.Bar%logger{0}mainPackage.sub.sample.BarBar%logger{5}mainPackage.sub.sample.Barm.s.s.Bar%logger{10}mainPackage.sub.sample.Barm.s.s.Bar%logger{15}mainPackage.sub.sample.Barm.s.sample.Bar%logger{16}mainPackage.sub.sample.Barm.sub.sample.Bar%logger{26}mainPackage.sub.sample.BarmainPackage.sub.sample.BarPlease note that the rightmost segment in a logger name is never abbreviated, even if its length is longer than the *length* option. Other segments may be shortened to at most a single character but are never removed. |      |      |
| **C**{*length*} **class**{*length*}                          | Outputs the fully-qualified class name of the caller issuing the logging request.Just like the *%logger* conversion word above, this conversion takes an integer as an option to shorten the class name. Zero carries special meaning and will cause the simple class name to be printed without the package name prefix. By default the class name is printed in full.Generating the caller class information is not particularly fast. Thus, its use should be avoided unless execution speed is not an issue. |      |      |
| **contextName** **cn**                                       | Outputs the name of the logger context to which the logger at the origin of the event was attached to. |      |      |
| **d**{*pattern*} **date**{*pattern*} **d**{*pattern*, *timezone*} **date**{*pattern*, *timezone*} | 第二个参数指定时区。用于输出日志事件的日期。日期转换字允许模式字符串作为参数。模式语法与java.text.SimpleDateFormat所接受的格式兼容。Used to output the date of the logging event. The date conversion word admits a pattern string as a parameter. The pattern syntax is compatible with the format accepted by [`java.text.SimpleDateFormat`](https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html).You can specify the string *"ISO8601"* for the ISO8601 date format. Note that the %date conversion word defaults to the [ISO 8601 date format](http://en.wikipedia.org/wiki/ISO_8601) in the absence of a pattern parameter.Here are some sample parameter values. They assume that the actual date is Friday 20th of October, 2006 and that the author has returned to working on this document just after lunch.Conversion PatternResult%d2006-10-20 14:06:49,812%date2006-10-20 14:06:49,812%date{ISO8601}2006-10-20 14:06:49,812%date{HH:mm:ss.SSS}14:06:49.812%date{dd MMM yyyy;HH:mm:ss.SSS}20 oct. 2006;14:06:49.812The second parameter specifies a timezone. For example, the '%date{HH:mm:ss.SSS, Australia/Perth} would print the time in the time zone of Perth, Australia, the world's most isolated city. Note that in the absence of the timezone parameter, the default timezone of the host Java platform is used. If the specified timezone identifier is unknown or misspelled, the GMT timezone is assumed as dictated by the [TimeZone.getTimeZone(String)](http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)) method specification.**COMMON ERROR** Given that the comma ',' character is interpreted as the parameter separator, the pattern `HH:mm:ss,SSS` will be interpreted as the pattern `HM:mm:ss` and the timezone `SSS`. If you wish to include a comma in your date pattern, then simply enclose the pattern between quotes. For example, %date{**"**HH:mm:ss,SSS**"**}. |      |      |
|                                                              | 您可以为ISO8601日期格式指定字符串“ISO8601”。注意，在没有模式参数的情况下，%date转换字默认为ISO 8601日期格式。 |      |      |
| **F / file**                                                 | 下面是一些示例参数值。他们假设实际日期是2006年10月20日(星期五)，而作者在午饭后又回到了这个文档的工作中。Outputs the file name of the Java source file where the logging request was issued.Generating the file information is not particularly fast. Thus, its use should be avoided unless execution speed is not an issue. |      |      |
| **caller{depth}** **caller{depthStart..depthEnd}** **caller{depth, evaluator-1, ... evaluator-n}** **caller{depthStart..depthEnd, evaluator-1, ... evaluator-n}** | Outputs location information of the caller which generated the logging event.The location information depends on the JVM implementation but usually consists of the fully qualified name of the calling method followed by the caller's source, the file name and line number between parentheses.A integer can be added to the *caller* conversion specifier's options to configure the depth of the information to be displayed.For example, **%caller{2}** would display the following excerpt:`0    [main] DEBUG - logging statement  Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22) Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)`And **%caller{3}** would display this other excerpt:`16   [main] DEBUG - logging statement  Caller+0   at mainPackage.sub.sample.Bar.sampleMethodName(Bar.java:22) Caller+1   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17) Caller+2   at mainPackage.ConfigTester.main(ConfigTester.java:38)`A range specifier can be added to the *caller* conversion specifier's options to configure the depth range of the information to be displayed.For example, **%caller{1..2}** would display the following excerpt:`0    [main] DEBUG - logging statement Caller+0   at mainPackage.sub.sample.Bar.createLoggingRequest(Bar.java:17)`This conversion word can also use evaluators to test logging events against a given criterion before computing caller data. For example, using **%caller{3, CALLER_DISPLAY_EVAL}** will display three lines of stacktrace, only if the evaluator called *CALLER_DISPLAY_EVAL* returns a **positive** answer.Evaluators are described below. |      |      |
| **L / line**                                                 | Outputs the line number from where the logging request was issued.Generating the line number information is not particularly fast. Thus, its use should be avoided unless execution speed is not an issue. |      |      |
| **m / msg / message**                                        | Outputs the application-supplied message associated with the logging event. |      |      |
| **M / method**                                               | Outputs the method name where the logging request was issued.Generating the method name is not particularly fast. Thus, its use should be avoided unless execution speed is not an issue. |      |      |
| **n**                                                        | Outputs the platform dependent line separator character or characters.This conversion word offers practically the same performance as using non-portable line separator strings such as "\n", or "\r\n". Thus, it is the preferred way of specifying a line separator. |      |      |
| **p / le / level**                                           | Outputs the level of the logging event.                      |      |      |
| **r / relative**                                             | Outputs the number of milliseconds elapsed since the start of the application until the creation of the logging event. |      |      |
| **t / thread**                                               | Outputs the name of the thread that generated the logging event. |      |      |
| **X**{*key:-defaultVal*} **mdc**{*key:-defaultVal*}          | Outputs the MDC (mapped diagnostic context) associated with the thread that generated the logging event.If the **mdc** conversion word is followed by a key between braces, as in **%mdc{userid}**, then the MDC value corresponding to the key 'userid' will be output. If the value is null, then the [default value](http://logback.qos.ch/manual/configuration.html#defaultValuesForVariables) specified after the **:-** operator is output. If no default value is specified than the empty string is output.If no key is given, then the entire content of the MDC will be output in the format "key1=val1, key2=val2".See the [chapter on MDC](http://logback.qos.ch/manual/mdc.html) for more details on the subject. |      |      |
| **ex**{*depth*} **exception**{*depth*} **throwable**{*depth*}  **ex**{depth, evaluator-1, ..., evaluator-n} **exception**{depth, evaluator-1, ..., evaluator-n} **throwable**{depth, evaluator-1, ..., evaluator-n} | Outputs the stack trace of the exception associated with the logging event, if any. By default the full stack trace will be output.The *throwable* conversion word can followed by one of the following options:*short*: prints the first line of the stack trace*full*: prints the full stack traceAny integer: prints the given number of lines of the stack traceHere are some examples:Conversion PatternResult%ex`mainPackage.foo.bar.TestException: Houston we have a problem  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)`%ex{short}`mainPackage.foo.bar.TestException: Houston we have a problem  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)`%ex{full}`mainPackage.foo.bar.TestException: Houston we have a problem  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)  at mainPackage.ExceptionLauncher.main(ExceptionLauncher.java:38)`%ex{2}`mainPackage.foo.bar.TestException: Houston we have a problem  at mainPackage.foo.bar.TestThrower.fire(TestThrower.java:22)  at mainPackage.foo.bar.TestThrower.readyToLaunch(TestThrower.java:17)`This conversion word can also use evaluators to test logging events against a given criterion before creating the output. For example, using **%ex{full, EX_DISPLAY_EVAL}** will display the full stack trace of the exception only if the evaluator called *EX_DISPLAY_EVAL* returns a **negative** answer. Evaluators are described further down in this document.If you do not specify %throwable or another throwable-related conversion word in the conversion pattern, `PatternLayout` will automatically add it as the last conversion word, on account of the importance of stack trace information. The $nopex conversion word can be substituted for %throwable, if you do not wish stack trace information to be displayed. See also the %nopex conversion word. |      |      |
| **xEx**{*depth*} **xException**{*depth*} **xThrowable**{*depth*}  **xEx**{depth, evaluator-1, ..., evaluator-n} **xException**{depth, evaluator-1, ..., evaluator-n} **xThrowable**{depth, evaluator-1, ..., evaluator-n} | Same as the %throwable conversion word above with the addition of class packaging information.At the end of each stack frame of the exception, a string consisting of the jar file containing the relevant class followed by the "Implementation-Version" as found in that jar's manifest will be added. This innovative technique was [originally suggested by James Strachan](http://macstrac.blogspot.com/2008/09/better-stack-traces-in-java-with-log4j.html). If the information is uncertain, then the class packaging data will be preceded by a tilde, i.e. the '~' character.Here is an example:java.lang.NullPointerException  at com.xyz.Wombat(Wombat.java:57) **~[wombat-1.3.jar:1.3]**  at  com.xyz.Wombat(Wombat.java:76) ~[wombat-1.3.jar:1.3]  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.5.0_06]  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) ~[na:1.5.0_06]  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) ~[na:1.5.0_06]  at java.lang.reflect.Method.invoke(Method.java:585) ~[na:1.5.0_06]  at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59) [junit-4.4.jar:na]  at org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98) [junit-4.4.jar:na]  ...etc Logback goes to great lengths to ensure that the class packaging information it displays is correct, even in arbitrarily complex class loader hierarchies. However, when it is unable to guarantee the absolute correctness of the information, then it will prefix the data with a tilde, i.e. the '~' character. Thus, it is theoretically possible for the printed class packaging information to differ from the real class packaging information. So, in the above example, given that packaging data for the Wombat class is preceded by a tilde, it is possible that the correct packaging data is in reality [wombat.jar:1.7].Please note that given its potential cost, computation of [**packaging data is disabled by default**](http://logback.qos.ch/manual/configuration.html#packagingData). When computation of packaging data is enabled, `PatternLayout` will automatically assume the %xThrowable suffix instead of %throwable suffix at the end of the pattern string.[Feedback from users](http://jira.qos.ch/browse/LBCLASSIC-212) indicates that Netbeans chokes on packaging information. |      |      |
| **nopex** **nopexception**                                   | Although it *pretends* to handle stack trace data, this conversion word does not output any data, thus, effectively ignoring exceptions.The %nopex conversion word allows the user to override `PatternLayout`'s internal safety mechanism which silently adds the %xThrowable conversion keyword in the absence of another conversion word handling exceptions. |      |      |
| **marker**                                                   | Outputs the marker associated with the logger request.In case the marker contains children markers, the converter displays the parent as well as childrens' names according to the format shown below.*parentName [ child1, child2 ]* |      |      |
| **property{key}**                                            | Outputs the value associated with a property named *key*. The the relevant docs on how to define ion entitled [define variables](http://logback.qos.ch/manual/configuration.html#variableSubstitution) and [variable scopes](http://logback.qos.ch/manual/configuration.html#scopes). If *key* is not a property of the logger context, then *key* will be looked up in the System properties.There is no default value for *key*. If it is omitted, the returned value will be "Property_HAS_NO_KEY", expliciting the error condition. |      |      |
| **replace(\*p\*){r, t}**                                     | Replaces occurrences of 'r', a regex, with its replacement 't' in the string produces by the sub-pattern 'p'. For example, "%replace(%msg){'\s', ''}" will remove all spaces contained in the event message.The pattern 'p' can be arbitrarily complex and in particular can contain multiple conversion keywords. For instance, "%replace(%logger %msg){'\.', '/'}" will replace all dots in the logger or the message of the event with a forward slash. |      |      |
| **rEx**{*depth*} **rootException**{*depth*}  **rEx**{depth, evaluator-1, ..., evaluator-n} **rootException**{depth, evaluator-1, ..., evaluator-n} | Outputs the stack trace of the exception associated with the logging event, if any. The root cause will be output first instead of the standard "root cause last". Here is a sample output (edited for space):`java.lang.NullPointerException  at com.xyz.Wombat(Wombat.java:57) ~[wombat-1.3.jar:1.3]  at com.xyz.Wombat(Wombat.java:76) ~[wombat-1.3.jar:1.3] Wrapped by: org.springframework.BeanCreationException: Error creating bean with name 'wombat':   at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:248) [spring-2.0.jar:2.0]  at org.springframework.AbstractBeanFactory.getBean(AbstractBeanFactory.java:170) [spring-2.0.jar:2.0]  at org.apache.catalina.StandardContext.listenerStart(StandardContext.java:3934) [tomcat-6.0.26.jar:6.0.26] `The %rootException converter admits the same optional parameters as the %xException converter described above, including depth and evaluators. It outputs also packaging information. In short, %rootException is very similar to %xException, only the order of exception output is reversed.Tomasz Nurkiewicz, the author of %rootException converter, documents his contribution in a blog entry entitled ["Logging exceptions root cause first"](http://nurkiewicz.blogspot.com/2011/09/logging-exceptions-root-cause-first.html). |      |      |

| Conversion Pattern              | Result                    |
| ------------------------------- | ------------------------- |
| %d                              | 2006-10-20 14:06:49,812   |
| %date                           | 2006-10-20 14:06:49,812   |
| %date{ISO8601}                  | 2006-10-20 14:06:49,812   |
| %date{HH:mm:ss.SSS}             | 14:06:49.812              |
| %date{dd MMM yyyy;HH:mm:ss.SSS} | 20 oct. 2006;14:06:49.812 |

##### 紧接转换字之后的字面值限制

在大多数情况下，字面值自然包含空格或其他分隔字符，因此它们不会与转换字混淆。例如，模式“%level [%thread] - %message%n”包含字符串“[”和“]-”。但是，如果可以作为java标识符一部分的字符紧跟在转换字之后，logback的模式解析器就会误以为文字是转换字的一部分。例如，模式“%date%nHello”将被解释为两个转换字%date和%nHello，由于%nHello不是一个已知的转换字，所以logback将为%nHello输出%PARSER_ERROR[nHello]。如果希望字符串文字“Hello”立即将%n和Hello分隔开，请将空参数列表传递给%n。例如，“%date%n{}Hello”将被解释为%date后跟%n后跟文字“Hello”。

##### 可选的格式修饰符

第一个可选的格式修饰符是左对齐标志，它就是-(-)字符。然后是可选的最小字段宽度调整器。这是一个十进制常量，表示要输出的最小字符数。如果数据项包含的字符较少，则在左边或右边填充该数据项，直到达到最小宽度为止。默认设置是左对齐(右对齐)，但是您可以使用左对齐标志指定右对齐。填充字符是空格。如果数据项大于最小字段宽度，则扩展字段以容纳数据。值永远不会被截断。

可以使用最大字段宽度修饰符更改此行为，该修饰符由一个句点后跟一个十进制常数指定。如果数据项比最大字段长，则从数据项的开头删除额外的字符。例如，如果最大字段宽度为8，数据项长度为10个字符，那么数据项的前两个字符将被删除。这种行为与C语言中的printf函数有所不同，后者的截断是从末尾开始的。

从末尾开始截断可以在句点后面追加一个减号。在这种情况下，如果最大字段宽度为8，数据项长度为10个字符，那么数据项的最后两个字符将被删除。比如最后一个示例

下面是日志转换说明符的各种格式修饰符示例。

| Format modifier | Left justify | Minimum width | Maximum width | Comment                                                      |
| --------------- | ------------ | ------------- | ------------- | ------------------------------------------------------------ |
| %20logger       | false        | 20            | none          | Left pad with spaces if the logger name is less than 20 characters long. |
| %-20logger      | true         | 20            | none          | Right pad with spaces if the logger name is less than 20 characters long. |
| %.30logger      | NA           | none          | 30            | Truncate from the beginning if the logger name is longer than 30 characters. |
| %20.30logger    | false        | 20            | 30            | Left pad with spaces if the logger name is shorter than 20 characters. However, if logger name is longer than 30 characters, then truncate from the beginning. |
| %-20.30logger   | true         | 20            | 30            | Right pad with spaces if the logger name is shorter than 20 characters. However, if logger name is longer than 30 characters, then truncate from the *beginning*. |
| %.-30logger     | NA           | none          | 30            | Truncate from the *end* if the logger name is longer than 30 characters. |

#### filter

Logback-classic offers two types of filters, regular filters and turbo filters.

过滤器被组织成一个有序的列表，并且基于三元逻辑。依次调用每个过滤器的decide(ILoggingEvent event)方法。该方法返回一个FilterReply枚举值，即一个DENY、NEUTRAL或ACCEPT。如果decide()返回的值为DENY，则立即删除日志事件，而不咨询其他过滤器。如果返回的值是中性的，那么将查询列表中的下一个过滤器。如果没有其他筛选器可供参考，则日志事件将正常处理。如果返回的值是ACCEPT，那么日志事件将被立即处理，跳过剩余过滤器的调用。

在logback-classic中，可以将筛选器添加到Appender实例中。通过向追加器添加一个或多个过滤器，您可以根据任意条件对事件进行过滤，例如日志消息的内容、MDC的内容、一天的时间或日志事件的任何其他部分。

##### LevelFilter

LevelFilter基于精确的级别匹配过滤事件。如果事件的级别等于配置的级别，则筛选器接受或拒绝事件，这取决于onMatch和on失配属性的配置。下面是一个示例配置文件。

~~~xml
<configuration>
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>INFO</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
    <encoder>
      <pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      </pattern>
    </encoder>
  </appender>
  <root level="DEBUG">
    <appender-ref ref="CONSOLE" />
  </root>
</configuration>
~~~

##### ThresholdFilter

阈值过滤器过滤指定阈值以下的事件。对于级别等于或高于阈值的事件，在调用其decide()方法时，阈值过滤器将响应中性。但是，级别低于阈值的事件将被拒绝。下面是一个示例配置文件。

~~~xml
<configuration>
  <appender name="CONSOLE"
    class="ch.qos.logback.core.ConsoleAppender">
    <!-- deny all events with a level below INFO, that is TRACE and DEBUG -->
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>INFO</level>
    </filter>
    <encoder>
      <pattern>
        %-4relative [%thread] %-5level %logger{30} - %msg%n
      </pattern>
    </encoder>
  </appender>
  <root level="DEBUG">
    <appender-ref ref="CONSOLE" />
  </root>
</configuration>
~~~

